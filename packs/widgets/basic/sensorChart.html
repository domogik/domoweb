<dom-module id="dmw-basic-sensorchart">
    <template id="extended-styles">
        <style type="text/css">
            :host {
                height: 100%;
                display: block;
            }
            #spark {
                height: 100%;
            }
            #chart {
                float: left;
                width: 35%;
                height: 100%;

            }
            #values {
                float: left;
                width: 65%;
                height: 100%;
            }
            #number {
                position: relative;
                top: 43%;
                -webkit-transform: translate(-50%, -50%);
                -ms-transform: translate(-50%, -50%);
                transform: translate(-50%, -50%);
                left: 50%;
                text-align: center;
                overflow: hidden;
                display: inline-block;
                padding: 10px;
            }
            #minmax {
                position: relative;
                top: -20%;
                -webkit-transform: translate(-50%, -50%);
                -ms-transform: translate(-50%, -50%);
                transform: translate(-50%, -50%);
                left: 50%;
                text-align: center;
                overflow: hidden;
                display: inline-block;
                width: 100%;
            }
            #minvalue {
            }
            #maxvalue {
            }
            #unit {
                position: absolute;
                top:5px;
                right: 5px;
                font-size: 1em;
            }
        </style>
        <dmw-sensor id='primary' sensorkey="primary" sensorvalue={{sensorvalue}} sensorhistory={{history}} sensornotified="number"></dmw-sensor>
        <shadow></shadow>
        <div id='chart'>
          <div id="spark" class="inlinesparkline">[[spark]]</div>
        </div>
        <div id='values'>
          <div id='number'>
          [[number]]
          </div>
          <div id='minmax'>
            <span id='minvalue'>[[min]]</span>&nbsp;<sup><em>{{localize('min')}}</em></sup>&nbsp;/&nbsp;
            <span id='maxvalue'>[[max]]</span>&nbsp;<sup><em>{{localize('max')}}</em></sup>
          </div>
        </div>
        <div id='unit'>[[unit]]</div>
    </template>
    <script src="/widget/basic/js/jquery.sparkline.min.js"></script>
    <script>
     (function () {
        let memoizedTemplate;

        class DmwBasicSensorChart extends DmwWidget {
            static get is () { return 'dmw-basic-sensorchart'; }
            static get properties() {
                return {
                    sensorvalue: {
                        notify: true,
                        observer: 'sensorvalueChanged'
                    },
                    history: {
                        notify: true,
                        observer: 'historyChanged',
                    }
                }
            }
            static get template() {
              if (!memoizedTemplate) {
                // start with clone of superclass template
                memoizedTemplate = DmwWidget.template.cloneNode(true);
                // get some stuff you want to insert into super template
                const subStyle = Polymer.DomModule.import(this.is, 'template#extended-styles').content;
                // insert stuff in template after the super template's <style>
                const superStyle = memoizedTemplate.content.querySelector('style');
                superStyle.parentNode.insertBefore(subStyle, superStyle.nextSibling);
              }
              return memoizedTemplate;
            }
            constructor() {
                super();
            }
            connectedCallback() {
                super.connectedCallback();
                this.number = "--";
                this.unit = "";
                this.currentHistoryValue = [];
            }
            optionsUpdated() {
                if (this.options['hideLabels'] == true ) {
                    this.$.labelprimary.style.visibility = "hidden";
                    this.$.labelsecondary.style.visibility = "hidden";
                }
                else {
                    this.$.labelprimary.style.visibility = "visible";
                    this.$.labelsecondary.style.visibility = "visible";
                }
                this.draw(this.currentHistoryValue);
            }
            sensorsUpdated() {
                if (this.$.primary.isSet) {
                    this.labelprimary = this.$.primary.device['name'];
                    this.labelsecondary = this.$.primary.name;
                }
            }
            sensorvalueChanged(newValue, oldValue) {
                newValue = newValue.stored_value;
                if (!Number.isInteger(newValue)) {
                    newValue = parseFloat(newValue).toFixed(this.options['precision']);
                }
                var unit = this.datatypes[this.$.primary.datatype_id]['unit'];
                if (this.options['autoconvert']==1 && newValue > 0) {
                       var k = 1000;
                       var sizes = ['', 'K', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y'];
                       var i = Math.floor(Math.log(newValue) / Math.log(k));
                    this.$.number.innerHTML = (newValue / Math.pow(k, i)).toPrecision(this.options['precision']);
                    if (unit) {
                        this.unit = sizes[i] + this.localize("domoweb:unit", 'value', unit);
                    }
                } else {
                    if (newValue) {
                        this.$.number.innerHTML = newValue;
                    } else {this.$.number.innerHTML = '?';
                    }
                    if (unit) {
                        this.unit = this.localize("domoweb:unit", 'value', unit);
                    }
                }
                this.adjustText(this.clientWidth-this.$.chart.clientWidth+15, this.clientHeight, this.$.number);
                this.$.primary.getCurrentDayPerHour();

            }
            historyChanged(newValue,oldValue) {
                // in case the page is not yet nicely loaded...
                if (this.$.spark.clientWidth == 0 || this.$.spark.clientHeight == 0) {
                    setTimeout(function(){
                        this.historyChanged(newValue, oldValue);
                        }.bind(this), 1000);
                }
                else {
                    this.draw(newValue);
                }
            }
            draw(newValue) {
                if (newValue.length != 0) {
                    // to allow redraw when options changed
                    this.currentHistoryValue = newValue;

                    // draw
                    var self = this;
                    var chartValues = [];
                    for(var i=0;i<newValue.length;i++) {
                        // 5 because : [ year, month, week, day, hour, value ]
                        chartValues.push(newValue[i][5]);
                    }
                    // display the chart
                    var minvalue = Math.min.apply(Math, chartValues).toPrecision(3);
                    var maxvalue = Math.max.apply(Math, chartValues).toPrecision(3);

                    // as the graph history is an average, the current value could be lower or bigger than the min/max average value. So we adjust
                    var current = this.$.number.innerHTML;
                    if (current > maxvalue) {
                        this.max = current;
                    }
                    else {
                        this.max = maxvalue;
                    }
                    if (current < minvalue) {
                        this.min = current;
                    }
                    else {
                        this.min = minvalue;
                    }
                    $(this.$.spark).sparkline(chartValues, {type: 'line',
                                                            lineColor: this.options['chartColor'],
                                                            fillColor: this.options['chartColor'],
                                                            spotColor: "",
                                                            minSpotColor: "",
                                                            maxSpotColor: "",
                                                            chartRangeMin: parseFloat(this.options['chartMinValue']),
                                                            chartRangeMax: parseFloat(this.options['chartMaxValue']),
                                                            height: '100%', width: '100%'Â });
                    $.sparkline_display_visible();
                }
            }
            adjustText(maxWidth, maxHeight, element) {
                var fontsize = window.getComputedStyle(element,null).getPropertyValue("font-size");
                var i = fontsize.substr(0,2);
                if (maxWidth == 0 || maxHeight == 0) {
                    setTimeout(function(){
                        this.adjustText(maxWidth, maxHeight, element);
                        }.bind(this), 1000);
                }
                else {
                    if (maxWidth > element.clientWidth && maxHeight > element.clientHeight) {
                        while ( maxWidth > element.clientWidth && maxHeight > element.clientHeight && i < 100){
                            element.style.fontSize = i+"px";
                            i++;
                        }
                    } else if (maxWidth < element.clientWidth || maxHeight < element.clientHeight) { // If text is bigger than widget
                        while (maxWidth < element.clientWidth || maxHeight < element.clientHeight){
                            element.style.fontSize = i+"px";
                            i--;
                        }
                    }
                }
            }
        };
        customElements.define(DmwBasicSensorChart.is, DmwBasicSensorChart);
    })();
    </script>
</dom-module>
