<dom-module id="dmw-basic-sensorchart2">
    <template id="extended-styles">
        <style type="text/css">
            :host {
                height: 100%;
                display: block;
            }
            #spark {
                height: 100%;
            }
            #chart {
                position: absolute;
                bottom: 2%;
                left: 2%;
                width: 96%;
                height: 38%;
                overflow: hidden;
            }
            #thedevicename {
                position: relative;
                white-space: nowrap;
                top: 5%;
                left: 5%;
                overflow: hidden;
                width: 93%;
                font-size: calc(1.8em*var(--wscale-h)*var(--wscale-r));
            }
            #container {
                position: absolute;
                top: 18%;
                left: 5%;
                height: 25%;
                width: 94%;
            }
            #adjusted {
                position: relative;
                display: inline-block;
            }
            #adjusted .unit {
                font-size: 0.8em;
                vertical-align: top;
                height: 100%;
            }
            #minmax {
                position: absolute;
                top: 47%;
                left: 5%;
                overflow: hidden;
                display: inline-block;
                width: 94%;
            }
            #minvalue {
            }
            #maxvalue {
            }
        </style>
        <dmw-sensor id='primary' sensorkey="primary" sensorvalue="{{sensorvalue}}" sensorhistory="{{history}}" sensornotified="adjusted"></dmw-sensor>
        <div id='thedevicename'>{{ devicename }}</div>
        <div id='container'>
          <div id='adjusted'>
              {{number}} <span class="unit">{{unit}}</div>
          </div>
        </div>
        <div id='minmax'>
          <span id='minvalue'>{{min}}</span>&nbsp;<sup><em>min</em></sup>&nbsp;/&nbsp;
          <span id='maxvalue'>{{max}}</span>&nbsp;<sup><em>max</em></sup>
        </div>
        <div id='chart'>
          <div id="spark" class="inlinesparkline">{{spark}}</div>
        </div>
    </template>
    <script src="/widget/basic/js/jquery.sparkline.min.js"></script>
    <script>
     (function () {
        let memoizedTemplate;

        class DmwBasicSensorChart2 extends DmwWidget {
            static get is () { return 'dmw-basic-sensorchart2'; }
            static get properties() {
                return {
                    sensorvalue: {
                        notify: true,
                        observer: 'sensorvalueChanged'
                    },
                    history: {
                        notify: true,
                        observer: 'historyChanged',
                    }
                }
            }
            static get template() {
              if (!memoizedTemplate) {
                // start with clone of superclass template
                memoizedTemplate = DmwWidget.template.cloneNode(true);
                // get some stuff you want to insert into super template
                const subStyle = Polymer.DomModule.import(this.is, 'template#extended-styles').content;
                // insert stuff in template after the super template's <style>
                const superStyle = memoizedTemplate.content.querySelector('style');
                superStyle.parentNode.insertBefore(subStyle, superStyle.nextSibling);
              }
              return memoizedTemplate;
            }
            constructor() {
                super();
                this.ratioConstraint = 'width';
            }
            connectedCallback() {
                super.connectedCallback();
                this.devicename = "";
                this.number = "";
                this.unit = "";
                this.currentHistoryValue = [];
            }
            resized() {
                this.adjustText(this.$.container, this.$.adjusted);
                if (this.currentHistoryValue) {
                    this.draw(this.currentHistoryValue);
                }
            }
            optionsUpdated() {
                if (this.options['hideLabels'] == true ) {
                    this.$.labelprimary.style.visibility = "hidden";
                    this.$.labelsecondary.style.visibility = "hidden";
                }
                else {
                    this.$.labelprimary.style.visibility = "visible";
                    this.$.labelsecondary.style.visibility = "visible";
                }
                this.draw(this.currentHistoryValue);
            }
            sensorsUpdated() {
                if (this.$.primary.isSet) {
                    this.devicename = this.$.primary.device['name'];
                    this.labelprimary = this.$.primary.device['name'];
                    this.labelsecondary = this.$.primary.name;
                }
            }
            sensorvalueChanged(newValue, oldValue) {
                newValue = newValue.stored_value;
                if (!Number.isInteger(newValue)) {
                    newValue = parseFloat(newValue).toFixed(this.options['precision']);
                }
                var unit = this.datatypes[this.$.primary.datatype_id]['unit'];
                if (this.options['autoconvert']==1 && newValue > 0) {
                       var k = 1000;
                       var sizes = ['', 'K', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y'];
                       var i = Math.floor(Math.log(newValue) / Math.log(k));
                    this.number = (newValue / Math.pow(k, i)).toPrecision(3);
                    if (unit) {
                        this.unit = sizes[i] + this.localize("domoweb:unit", 'value', unit);
                    }
                } else {
                    this.number = newValue;
                    if (unit) {
                        this.unit = this.localize("domoweb:unit", 'value', unit);
                    }
                }
                this.adjustText(this.$.container, this.$.adjusted);
                this.$.primary.getCurrentDayPerHour();

            }
            historyChanged(newValue, oldValue) {
                // in case the page is not yet nicely loaded...
                if (this.$.spark.clientWidth == 0 || this.$.spark.clientHeight == 0) {
                    setTimeout(function(){
                        this.historyChanged(newValue, oldValue);
                        }.bind(this), 1000);
                }
                else {
                    this.draw(newValue);
                }
            }
            draw(newValue) {
                // to allow redraw when options changed
                this.currentHistoryValue = newValue;

                // draw
                var self = this;
                var chartValues = [];
                for(var i=0;i<newValue.length;i++) {
                    // 5 because : [ year, month, week, day, hour, value ]
                    chartValues.push(newValue[i][5]);
                }
                // display the chart
                var minvalue = Math.min.apply(Math, chartValues).toPrecision(3);
                var maxvalue = Math.max.apply(Math, chartValues).toPrecision(3);

                // as the graph history is an average, the current value could be lower or bigger than the min/max average value. So we adjust
                var current = this.number;
                if (current > maxvalue) {
                    this.max = current;
                }
                else {
                    this.max = maxvalue;
                }
                if (current < minvalue) {
                    this.min = current;
                }
                else {
                    this.min = minvalue;
                }
                //console.log("color:" + this.options['chartColor']);
                //console.log("colornew:" + this.hexToRgbA(this.options['chartColor']));
                $(this.$.spark).sparkline(chartValues, {type: 'line',
                                                        lineColor: this.options['chartColor'],
                                                        fillColor: this.hexToRgbA(this.options['chartColor']),
                                                        spotColor: "",
                                                        minSpotColor: "",
                                                        maxSpotColor: "",
                                                        chartRangeMin: parseFloat(this.options['chartMinValue']),
                                                        chartRangeMax: parseFloat(this.options['chartMaxValue']),
                                                        height: '100%', width: '100%'Â });
                $.sparkline_display_visible();
            }
            hexToRgbA(hex){
                // From : https://stackoverflow.com/questions/21646738/convert-hex-to-rgba
                // Add opacity
                var c;
                if(/^#([A-Fa-f0-9]{3}){1,2}$/.test(hex)){
                    c= hex.substring(1).split('');
                    if(c.length== 3){
                        c= [c[0], c[0], c[1], c[1], c[2], c[2]];
                    }
                    c= '0x'+c.join('');
                    return 'rgba('+[(c>>16)&255, (c>>8)&255, c&255].join(',')+',0.3)';
                }
                throw new Error('Bad Hex');
            }
	    };
        customElements.define(DmwBasicSensorChart2.is, DmwBasicSensorChart2);
    })();
    </script>
</dom-module>
