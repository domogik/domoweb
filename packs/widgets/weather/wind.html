<style>
/* NEW 2.0 */
@font-face {
  font-family: 'weathericons';
  src: url('/widget/weather/weather-icons-master-2.0/font/weathericons-regular-webfont.eot');
  src: url('/widget/weather/weather-icons-master-2.0/font/weathericons-regular-webfont.eot?#iefix') format('embedded-opentype'), url('/widget/weather/weather-icons-master-2.0/font/weathericons-regular-webfont.woff2') format('woff2'), url('/widget/weather/weather-icons-master-2.0/font/weathericons-regular-webfont.woff') format('woff'), url('/widget/weather/weather-icons-master-2.0/font/weathericons-regular-webfont.ttf') format('truetype'), url('/widget/weather/weather-icons-master-2.0/font/weathericons-regular-webfont.svg#weather_iconsregular') format('svg');
  font-weight: normal;
  font-style: normal;
}

</style>
<dom-module id="dmw-weather-wind">
    <template id="extended-styles">
        <link rel="stylesheet" href="/widget/weather/weather-icons-master-2.0/css/weather-icons.css">
        <style is="custom-style">
            :host {
                --arrow-w: 50px;
            }
            .inactive {
                display: none;
            }
            ::content #labelprimary {
                position: absolute;
                top: 10px;
                left: 10px;
                font-size: 1.2em;
            }
            #center {
                position: absolute;
                top: 45%;
                left: 50%;
                width: 10px;
                height: 10px;
                border-radius: 5px;
                margin: -5px 0 0 -5px;
                background-color: #ffffff;
            }
            #arrow {
                position: absolute;
                left: 50%;
                top: 45%;
                margin: calc(-30px*var(--wscale-w)) 0 0 -15px;
                transform-origin: center center;
                transition: all 1s ease;
            }
            #arrow polygon {
                fill : #ffffff;
            }
            #speeddisplay {
                position: absolute;
                bottom: 2px;
                right: 5px;
                font-size: calc(0.7em*var(--wscale-h)*var(--wscale-r));
            }
            #gustdisplay {
                position: absolute;
                bottom: 2px;
                left: 5px;
                font-size: calc(0.7em*var(--wscale-h)*var(--wscale-r));
            }
        </style>
        <slot>
            <dmw-sensor id='direction' sensorkey="direction" sensorvalue="{{directionvalue}}" sensornotified="compass"></dmw-sensor>
            <dmw-sensor id='speed' sensorkey="speed" sensorvalue="{{speedvalue}}"></dmw-sensor>
            <dmw-sensor id='gust' sensorkey="gust" sensorvalue="{{gustvalue}}"></dmw-sensor>
        </slot>
        <canvas id="compass" width="{{sizew}}" height="{{sizeh}}"></canvas>
        <div id="center" class="center"></div>
        <svg class="inactive" version="1.1" id="arrow" xmlns:svg="http://www.w3.org/2000/svg"
             xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="30px" height="50px"
             viewBox="167.9 396.6 30 100" style="enable-background:new 167.9 396.6 30 100;" xml:space="preserve">
        <g id="Ebene_1" transform="matrix(0,-2.4390522,2.4390522,0,7.7693439,1270.6714)">
            <polygon id="path2050" points="317.3,70.5 347.7,70.5 347.7,65.7 358.4,71.9 347.7,78 347.7,73.2 317.3,73.2     "/>
        </g>
        </svg>
        <div id="speeddisplay" class="inactive">
          <i class="wi wi-strong-wind"></i>{{speed}}&nbsp;{{speedunit}}
        </div>
        <div id="gustdisplay" class="inactive">
          <i class="wi wi-tornado"></i>{{gust}}&nbsp;{{gustunit}}
        </div>
    </template>
    <script>
     (function () {
        let memoizedTemplate;

        class DmwWeatherWind extends DmwWidget {
            static get is () { return 'dmw-weather-wind'; }
            static get properties() {
                return {
                    directionvalue: {
                        notify: true,
                        observer: 'directionvalueChanged'
                    },
                    speedvalue: {
                        notify: true,
                        observer: 'speedvalueChanged'
                    },
                    gustvalue: {
                        notify: true,
                        observer: 'gustvalueChanged'
                    }
                }
            }
            static get template() {
              if (!memoizedTemplate) {
                // start with clone of superclass template
                memoizedTemplate = DmwWidget.template.cloneNode(true);
                // get some stuff you want to insert into super template
                const subStyle = Polymer.DomModule.import(this.is, 'template#extended-styles').content;
                // insert stuff in template after the super template's <style>
                const superStyle = memoizedTemplate.content.querySelector('style');
                superStyle.parentNode.insertBefore(subStyle, superStyle.nextSibling);
              }
              return memoizedTemplate;
            }
            constructor() {
                super();
                this.ratioConstraint = 'width';
                this.direction = 90;
            }
            connectedCallback() {
                super.connectedCallback();
            }
            resized(){
                const context = this.$.compass.getContext('2d');
                context.clearRect(0, 0, this.sizew, this.sizeh);
                this.sizew = this.clientWidth;
                this.sizeh = this.clientHeight;
                this.centerX = this.sizew/2;
                this.centerY = (this.sizeh/2) - 10;
                const radius = (this.sizew/2) - (15 * this.scales.width);
                let color =  "#ffffff";
                if (this.options) {
                    color = (this.options['WidgetTextColor'] == undefined) ? "#ffffff" : this.options['WidgetTextColor'];
                }
                context.lineWidth = 2;
                context.strokeStyle = color;
                context.fillStyle = color;
                context.beginPath();
                context.arc(this.centerX, this.centerY, radius, 0.1*Math.PI, 0.4*Math.PI);
                context.stroke();
                context.beginPath();
                context.arc(this.centerX, this.centerY, radius, 0.6*Math.PI, 0.9*Math.PI);
                context.stroke();
                context.beginPath();
                context.arc(this.centerX, this.centerY, radius, 1.1*Math.PI, 1.4*Math.PI);
                context.stroke();
                context.beginPath();
                context.arc(this.centerX, this.centerY, radius, 1.6*Math.PI, 1.9*Math.PI);
                context.stroke();
                context.font = (10 * this.scales.width) + 'pt Verdana';
                context.fillText(this.localize('location:direction:W'), this.centerX - 5 - radius, this.centerY + 6);
                context.fillText(this.localize('location:direction:E'), this.centerX - 5 + radius, this.centerY + 6);
                context.fillText(this.localize('location:direction:S'), this.centerX - 5,  this.centerY + radius + 6);
                context.fillText(this.localize('location:direction:N'), this.centerX - 5, this.centerY- radius + 6);
                this.$.arrow.setAttribute('height', `${60*this.scales.width}px`);
            }
            sensorsUpdated() {
                this.$.compass.width = this.clientWidth;
                this.$.compass.height = this.clientHeight;
                if (this.$.compass.width == 0 || this.$.compass.height == 0) {
                    setTimeout(function(){
                        this.sensorsUpdated();
                        }.bind(this), 1000);
                }
                else {
                    if (this.$.direction.isSet) {
                        this.labelprimary = this.$.direction.device['name'];
                        //this.labelsecondary = this.$.direction.name;
                        this.$.arrow.classList.remove('inactive');
                    } else {
                        this.$.arrow.classList.add('inactive');
                    }
                    if (this.$.speed.isSet) {
                        this.$.speeddisplay.setAttribute('aria-label', this.localize('weather:speed'));
                        this.$.speeddisplay.classList.remove('inactive');
                    } else {
                        this.$.speeddisplay.classList.add('inactive');
                    }
                    if (this.$.gust.isSet) {
                        this.$.gustdisplay.setAttribute('aria-label', this.localize('weather:gust'));
                        this.$.gustdisplay.classList.remove('inactive');
                    } else {
                        this.$.gustdisplay.classList.add('inactive');
                    }
                    this.resized();
                }
            }
            directionvalueChanged(newValue, oldValue) {
                newValue = newValue.stored_value;
                this.$.center.style.backgroundColor = this.options['WidgetTextColor'];
                this.$.path2050.style.fill = this.options['WidgetTextColor'];
                this.$.arrow.style.transform = 'rotate(' + newValue + 'deg)';
                this.$.arrow.style.webkitTransform = 'rotate(' + newValue + 'deg)';
                this.direction = newValue;
            }
            speedvalueChanged(newValue, oldValue) {
                newValue = newValue.stored_value;
                this.speedunit = this.localize("domoweb:unit", "value", this.datatypes[this.$.speed.datatype_id]['unit'] );
                this.speed = newValue;
            }
            gustvalueChanged(newValue, oldValue) {
                newValue = newValue.stored_value;
                this.gustunit = this.localize("domoweb:unit", "value", this.datatypes[this.$.gust.datatype_id]['unit'] );
                this.gust = newValue;
            }
	    };
       customElements.define(DmwWeatherWind.is, DmwWeatherWind);
    })();
    </script>
</dom-module>
